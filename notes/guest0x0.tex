\section{Introduction}
Throughout this tutorial, \fbox{boxes} will be used in the following two cases:
\begin{itemize}
\item to clarify the precedences of symbols when formulae become too large. \\
e.g. \fbox{$\Gvdash \fbox{$\lam x M$}~:~\fbox{$(y:A)\to B$}
\Leftarrow \fbox{$\lam x u$}$}.
\item to distinguish type theory terms from natural language text. \\
e.g. ``we combine a term \fbox{$a$} with a term \fbox{$b$} to get a term \fbox{$a~b$}''.
\end{itemize}
\subsection{Target Audience}
This tutorial assumes familiarity with the following:
\begin{itemize}
\item Dependent type theory concepts, such as formation rules,
introduction rules, eliminators, etc., and functional programming.
\item Programming and theorem proving in a proof assistant based on dependent type theories.
\item The ability to translate (simple) typing rules into a type-checking procedures
and combine them into an algorithm.
\item Basic understanding of De Morgan cubical type theory~\cite{CCHM,CHM}
(hereafter as \CTT{}), including the interval type $\II$, the path type,
and the idea of representing cubes using terms with interval variables in it.
\end{itemize}
Some quick warm-ups:
\begin{exercise}
Translate the following typing rules into an algorithmic description:
\begin{mathpar}
\inferrule{\Gamma,x:A\vdash b:B[x/y]}{\Gvdash \fbox{$\lam x b$} : (y:A)\to B} \and
\inferrule{\Gvdash u : (x:A)\to B \\ \Gvdash v:A}{\Gvdash u~v:B[v/x]}
\end{mathpar}
Which of them is an introduction rule, and which is an elimination rule?
\end{exercise}
\begin{notation}
In this tutorial, instead of the more traditional \fbox{$\lambda x.b$},
the notation for $\lambda$-abstraction is \fbox{$\lam x b$} 
following the style of the Arend language.

Substitution is denoted by $u[v/x]$.
One may think of this notation as ``fractional multiplication'' $u\times \frac v x$,
where the denominator $x$ is cancelled out from $u$ and \textit{replaced} with the numerator $v$.
Other authors may use $u[x\mapsto v]$, $u[x:=v]$, $[v/x]u$, etc.

Propositional equality and path equivalence are both denoted $u=v$,
while definitional equality (a.k.a. judgmental equality) is denoted $u\equiv v$.
\end{notation}
\begin{exercise}\label{ex:concat-sym}
Consider path concatenation and symmetry in \CTT{}:
\begin{align*}
\concat&:(p:a=b)\to(q:b=c)\to{a=c}\\
\sym&:(p:a=b)\to{b=a}
\end{align*}
Define both using \hcomp{} on the following squares,
preferably in a cubical programming language:
% https://q.uiver.app?q=WzAsOCxbMCwwLCJhIl0sWzEsMCwiYyJdLFswLDEsImEiXSxbMSwxLCJiIl0sWzIsMSwiYSJdLFsyLDAsImIiXSxbMywxLCJhIl0sWzMsMCwiYSJdLFswLDEsIlxcY29uY2F0KHAsIHEpIl0sWzIsMCwiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiwzLCJwIiwyXSxbMywxLCJxIiwyXSxbNCw1LCJwIl0sWzQsNiwiIiwyLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiw3LCIiLDIseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs1LDcsIlxcc3ltKHApIl1d
\[\begin{tikzcd}
	a & c & b & a \\
	a & b & a & a
	\arrow["{\concat(p, q)}", from=1-1, to=1-2]
	\arrow[Rightarrow, no head, from=2-1, to=1-1]
	\arrow["p"', from=2-1, to=2-2]
	\arrow["q"', from=2-2, to=1-2]
	\arrow["p", from=2-3, to=1-3]
	\arrow[Rightarrow, no head, from=2-3, to=2-4]
	\arrow[Rightarrow, no head, from=2-4, to=1-4]
	\arrow["{\sym(p)}", from=1-3, to=1-4]
\end{tikzcd}\]
\end{exercise}
\subsection{Motivation}
This tutorial is intended to help readers get more familiar with how
\CTT{} works, what difficulties it is having in implementations,
what it can already do, and what it cannot do yet.

\CTT{} is a type theory evolved from a model using Kan cubical sets~\cite{CubicalSets},
which uses sophisticated mathematics, while computer scientists
usually do not have relevant courses taught in their undergraduate program.
But it is also the computer scientists who are suppose to implement \CTT{} as
programming languages. This tutorial tries to help those who did not study homotopy
theory, but wish to learn the internals of \CTT.

\CTT{} extends Martin-L\"{o}f type theory with huge new constructions,
especially the typing rules are written in a very compact way (like in~\cite{HCompPDF}).
This tutorial aims to discuss them from an algorithmic perspective,
and hopefully to inspire more people to implement cubical type theory,
to fuse these ideas into other work, or just to worship these brilliant ideas.

\section{Type checking cubes}\label{sec:tyck-cube}
This section motivates and explains typing judgments with cofibrations in the context.

\subsection{Interval and contexts}\label{sub:interval}
In \CTT, we have the interval type:
\[\vdash \isType\II\quad \vdash \lcon:\II \quad \vdash \rcon:\II\]
The interval type and its products are used to represent dimensions
(ignoring the De Morgan structures for now).
\begin{example}\label{ex:interval-in-ctx}
Suppose \fbox{$i:\II\vdash\isType{A}$} and \fbox{$i:\II\vdash u:A$}.
From a semantical or a topological perspective, we can say:
\begin{itemize}
\item $A$ is a (type) line between $A[\lcon/i]$ and $A[\rcon/i]$.
\item $u$ is a (term) line between $u[\lcon/i]$ and $u[\rcon/i]$.
\item The type of a line is a line, so the type of $u$ is $A$.
\end{itemize}
Then, because \emph{typing relations are preserved by substitution},
we have $u[\rcon/i]:A[\rcon/i]$ and $u[\lcon/i]:A[\lcon/i]$.
% https://q.uiver.app/?q=WzAsNixbMCwwLCJ1W1xcbGNvbi9pXSJdLFswLDEsInVbXFxyY29uL2ldIl0sWzIsMCwiQVtcXGxjb24vaV0iXSxbMiwxLCJBW1xcbGNvbi9pXSJdLFsxLDBdLFsxLDFdLFswLDEsInUiXSxbMiwzLCJBIl0sWzQsNSwiOiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}
	{u[\lcon/i]} & {} & {A[\lcon/i]} \\
	{u[\rcon/i]} & {} & {A[\lcon/i]}
	\arrow["u", from=1-1, to=2-1]
	\arrow["A", from=1-3, to=2-3]
	\arrow["{:}"{description}, draw=none, from=1-2, to=2-2]
\end{tikzcd}\]
\end{example}
From~\cref{ex:interval-in-ctx} we motivate the following notational
convention for contexts in \CTT, as in~\cref{not:ctx}.
\begin{notation}\label{not:ctx}
Typing judgments are written as \fbox{$\PGvdash \isType{A}$} and \fbox{$\PGvdash u:A$},
where \fbox{$\Phi;\Gamma$} is the usual \textit{context} in type theories,
with variables classified into two groups: if a variable has type $\II$,
it goes to $\Phi$, otherwise it goes to $\Gamma$.
\end{notation}
Note that~\cref{not:ctx} does not imply anything implementation-wise.

\subsection{Partial elements}\label{sub:partial}
In \CTT, we may not be able to describe every cube using a term,
like the squares in~\cref{ex:concat-sym}.
This motivates the idea of partial elements.
\begin{terminology}
We follow the terminology in~\cite{CubicalAgda}.
In~\cite{CCHM}, partial elements are called \textit{systems}.
\end{terminology}
Suppose we want to describe a square $i:\II,j:\II\vdash u:A$,
where $i$ goes from left to right and $j$ goes from bottom to top.
For simplicity we assume $\vdash \isType{A}$, say, $A$ does not depend on $i$ or $j$.
% https://q.uiver.app/?q=WzAsMyxbMCwxXSxbMSwxXSxbMCwwXSxbMCwxLCJpIl0sWzAsMiwiaiIsMl1d
\[\begin{tikzcd}
	{} \\
	{} & {}
	\arrow["i", from=2-1, to=2-2]
	\arrow["j"', from=2-1, to=1-1]
\end{tikzcd}\]
The goal is to make $u[\lcon/i, \rcon/j]\equiv a$ and $u[\rcon/i]\equiv v$.
From the goal we may deduce $\vdash a:A$ and $j:\II\vdash v:A$.
% https://q.uiver.app/?q=WzAsMyxbMCwwLCJhIl0sWzEsMCwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDFdLFsyLDEsInYiLDJdXQ==
\[\begin{tikzcd}
	a & \bullet \\
	& \bullet
	\arrow[from=1-1, to=1-2]
	\arrow["v"', from=2-2, to=1-2]
\end{tikzcd}\]
The above ``describing a cube by describing parts of its boundaries''
process is a just-need of \CTT, and such descriptions are called \textit{partial elements}.
In \CTT, we simply invent a syntax for them.
Intuitively we may write something like this:
\[\lrbbar{\begin{array}{rc}
  i\equiv\lcon \land j\equiv\rcon&\mapsto a\\
  i\equiv\rcon &\mapsto v
\end{array}}\]
To define this formally, we need to define the syntax of the left-hand-side of $\mapsto$.
They are called \textit{cofibrations} in \CTT.
