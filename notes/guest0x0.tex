\section{Introduction}
\subsection{Target Audience}
This tutorial assumes familiarity with the following:
\begin{itemize}
\item Dependent type theory concepts, such as formation rules,
introduction rules, eliminators, etc., and functional programming.
\item Programming and theorem proving in a proof assistant based on dependent type theories.
\item The ability to translate (simple) typing rules into a type-checking procedures
and combine them into an algorithm.
\item Basic understanding of De Morgan cubical type theory~\cite{CCHM,CHM}
(hereafter as \CTT{}), including the interval type $\II$, the path type,
and the idea of representing cubes using terms with interval variables in it.
\end{itemize}
Some quick warm-ups:
\begin{exercise}
Translate the following typing rules into an algorithmic description:
\begin{mathpar}
\inferrule{\Gamma,x:A\vdash b:B[x/y]}{\Gvdash \lam x b : (y:A)\to B} \and
\inferrule{\Gvdash u : (x:A)\to B \\ \Gvdash v:A}{\Gvdash u~v:B[v/x]}
\end{mathpar}
Which of them is an introduction rule, and which is an elimination rule?
\end{exercise}
\begin{notation}
In this tutorial, instead of the more traditional $\lambda x.b$, the notation for $\lambda$-abstraction is $\lam x b$ 
following the style of the Arend language. Furthermore, substitution is denoted by
$u[v/x]$. One may think of this notation as ``fractional multiplication'' $u\times \frac v x$,
where the denominator $x$ is cancelled out from $u$ and \textit{replaced} with the numerator $v$.
Other authors may use $u[x\mapsto v]$, $u[x:=v]$, $[v/x]u$, etc.
\end{notation}
\begin{exercise}
Define path concatenation in \CTT{} using \hcomp{}.
\end{exercise}
\subsection{Motivation}
This tutorial is intended to help readers get more familiar with how
\CTT{} works, what difficulties it is having in implementations,
what it can already do, and what it cannot do yet.

\CTT{} is a type theory evolved from a model using Kan cubical sets~\cite{CubicalSets},
which uses sophisticated mathematics, while computer scientists
usually do not have relevant courses taught in their undergraduate program.
But it is also the computer scientists who are suppose to implement \CTT{} as
programming languages. This tutorial tries to help those who did not study homotopy
theory, but wish to learn the internals of \CTT.

\CTT{} extends Martin-L\"{o}f type theory with huge new constructions,
especially the typing rules are written in a very compact way (like in~\cite{HCompPDF}).
This tutorial aims to discuss them from an algorithmic perspective,
and hopefully to inspire more people to implement cubical type theory,
to fuse these ideas into other work, or just to worship these brilliant ideas.

\section{Type checking cubes}\label{sec:tyck-cube}
This section motivates and explains typing judgments with cofibrations in the context.

\subsection{Syntax and notations}\label{sub:syntax}
We assume an informal understanding of type theory syntax, including
dependently-typed $\lambda$-calculus

In \CTT, 
