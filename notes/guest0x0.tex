\section{Introduction}
Throughout this tutorial, \fbox{boxes} will be used in the following two cases:
\begin{itemize}
\item to clarify the precedences of symbols when formulae become too large. \\
e.g. \fbox{$\Gvdash \fbox{$\lam x M$}~:~\fbox{$(y:A)\to B$}
\Leftarrow \fbox{$\lam x u$}$}.
\item to distinguish type theory terms from natural language text. \\
e.g. ``we combine a term \fbox{$a$} with a term \fbox{$b$} to get a term \fbox{$a~b$}''.
\end{itemize}
\subsection{Target Audience}
This tutorial assumes familiarity with the following:
\begin{itemize}
\item Dependent type theory concepts, such as formation rules,
introduction rules, eliminators, etc., and functional programming.
\item Programming and theorem proving in a proof assistant based on dependent type theories.
\item The ability to translate (simple) typing rules into a type-checking procedures
and combine them into an algorithm.
\item Basic understanding of De Morgan cubical type theory~\cite{CCHM,CHM}
(hereafter as \CTT{}), including the interval type $\II$, the path type,
and the idea of representing cubes using terms with interval variables in it.
\end{itemize}
This tutorial will not treat substitution formally.
Variable names are assumed to respect capture-avoiding substitution,
and can be implemented using any nameless representations.

Some quick warm-ups:
\begin{exercise}
Translate the following typing rules into an algorithmic description:
\begin{mathpar}
\inferrule{\Gamma,x:A\vdash b:B[x/y]}{\Gvdash \fbox{$\lam x b$} : (y:A)\to B} \and
\inferrule{\Gvdash u : (x:A)\to B \\ \Gvdash v:A}{\Gvdash u~v:B[v/x]}
\end{mathpar}
Which of them is an introduction rule, and which is an elimination rule?
\end{exercise}
\begin{notation}\label{not:pre}
In this tutorial, we will use $x, y, z$ for variables
and other Latin letters like $u,v,a,b,c,A,B,C$ for terms
(preferably uppercase for types and lowercase for terms).

We will write $u, A::=$ for syntax definition of terms.

Instead of the more traditional \fbox{$\lambda x.b$},
the notation for $\lambda$-abstraction is \fbox{$\lam x b$} 
following the style of the Arend language.

Substitution is denoted by $u[v/x]$.
One may think of this notation as ``fractional multiplication'' $u\times \frac v x$,
where the denominator $x$ is cancelled out from $u$ and \textit{replaced} with the numerator $v$.
Other authors may use $u[x\mapsto v]$, $u[x:=v]$, $[v/x]u$, etc.

Propositional equality and path equivalence are both denoted $u=v$,
while definitional equality (a.k.a. judgmental equality) is denoted $u\equiv v$.
\end{notation}
\begin{exercise}\label{ex:concat-sym}
Consider path concatenation and symmetry in \CTT{}:
\begin{align*}
\concat&:(p:a=b)\to(q:b=c)\to{a=c}\\
\sym&:(p:a=b)\to{b=a}
\end{align*}
Define both using \hcomp{} on the following squares,
preferably in a cubical programming language:
% https://q.uiver.app/?q=WzAsOCxbMCwwLCJhIl0sWzEsMCwiYyJdLFswLDEsImEiXSxbMSwxLCJiIl0sWzIsMSwiYSJdLFsyLDAsImIiXSxbMywxLCJhIl0sWzMsMCwiYSJdLFswLDEsIlxcY29uY2F0KHAsIHEpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzIsMCwiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiwzLCJwIiwyXSxbMywxLCJxIiwyXSxbNCw1LCJwIl0sWzQsNiwiIiwyLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiw3LCIiLDIseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs1LDcsIlxcc3ltKHApIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\[\begin{tikzcd}
	a & c & b & a \\
	a & b & a & a
	\arrow["{\concat(p, q)}", dashed, from=1-1, to=1-2]
	\arrow[Rightarrow, no head, from=2-1, to=1-1]
	\arrow["p"', from=2-1, to=2-2]
	\arrow["q"', from=2-2, to=1-2]
	\arrow["p", from=2-3, to=1-3]
	\arrow[Rightarrow, no head, from=2-3, to=2-4]
	\arrow[Rightarrow, no head, from=2-4, to=1-4]
	\arrow["{\sym(p)}", dashed, from=1-3, to=1-4]
\end{tikzcd}\]
\end{exercise}
\subsection{Motivation}
This tutorial is intended to help readers get more familiar with how
\CTT{} works, what difficulties it is having in implementations,
what it can already do, and what it cannot do yet.

\CTT{} is a type theory evolved from a model using Kan cubical sets~\cite{CubicalSets},
which uses sophisticated mathematics, while computer scientists
usually do not have relevant courses taught in their undergraduate program.
But it is also the computer scientists who are suppose to implement \CTT{} as
programming languages. This tutorial tries to help those who did not study homotopy
theory, but wish to learn the internals of \CTT.

\CTT{} extends Martin-L\"{o}f type theory with a huge amount of new constructions,
especially the typing rules are written in a very compact way (like in~\cite{HCompPDF}).
This tutorial aims to discuss them from an algorithmic perspective,
and hopefully to inspire more people to implement cubical type theory,
to fuse these ideas into other work, or just to worship these brilliant ideas.

This tutorial is a by-product of an experiment in implementing \CTT, called \GuestName,
a project created to encourage a particular person to learn \CTT.
The story ends up in the worst way: the person did not learn \CTT, and instead created
a new project to encourage the author of \GuestName{} to learn extensional type theory.

\section{Type checking cubes}\label{sec:tyck-cube}
This section motivates and explains typing judgments with cofibrations in the context.

\subsection{Interval and contexts}\label{sub:interval}
In \CTT, we have the interval type:
\[\vdash \isType\II\quad \vdash \lcon:\II \quad \vdash \rcon:\II\]
The interval type and its products are used to represent dimensions
(ignoring the De Morgan structures for now).
\begin{example}\label{ex:interval-in-ctx}
Suppose \fbox{$i:\II\vdash\isType{A}$} and \fbox{$i:\II\vdash u:A$}.
From a semantical or a topological perspective, we can say:
\begin{itemize}
\item $A$ is a (type) line between $A[\lcon/x]$ and $A[\rcon/x]$.
\item $u$ is a (term) line between $u[\lcon/x]$ and $u[\rcon/x]$.
\item The type of a line is a line, so the type of $u$ is $A$.
\end{itemize}
Then, because \emph{typing relations are preserved by substitution},
we have $u[\rcon/x]:A[\rcon/x]$ and $u[\lcon/x]:A[\lcon/x]$.
% https://q.uiver.app/?q=WzAsNixbMCwwLCJ1W1xcbGNvbi9pXSJdLFswLDEsInVbXFxyY29uL2ldIl0sWzIsMCwiQVtcXGxjb24vaV0iXSxbMiwxLCJBW1xcbGNvbi9pXSJdLFsxLDBdLFsxLDFdLFswLDEsInUiXSxbMiwzLCJBIl0sWzQsNSwiOiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}
	{u[\lcon/x]} & {} & {A[\lcon/x]} \\
	{u[\rcon/x]} & {} & {A[\lcon/x]}
	\arrow["u", from=1-1, to=2-1]
	\arrow["A", from=1-3, to=2-3]
	\arrow["{:}"{description}, draw=none, from=1-2, to=2-2]
\end{tikzcd}\]
\end{example}
From~\cref{ex:interval-in-ctx} we motivate the following notational
convention for contexts in \CTT, as in~\cref{not:ctx}.
\begin{notation}\label{not:ctx}
Typing judgments are written as \fbox{$\PGvdash \isType{A}$} and \fbox{$\PGvdash u:A$},
where \fbox{$\Phi;\Gamma$} is the usual \textit{context} in type theories,
with variables classified into two groups: if a variable has type $\II$,
it goes to $\Phi$, otherwise it goes to $\Gamma$.
This convention is borrowed from~\cite{ABCFHL}.
\end{notation}
Note that~\cref{not:ctx} does not imply that contexts has to be classified
in the implementations. The \GuestName{} type checker mix intervals
and other bindings in a unified context, just like usual dependent type checkers.

\subsection{Partial elements}\label{sub:partial}
In \CTT{}, the idea that \textit{open shapes can be filled}
is the core concept that makes terms in type theory space-like,
and to do so the \textit{Kan operation} are added to \CTT{} as a structure.

The motivation is that with only the interval type and Martin-L\"of type theory,
we may not be able to describe every cube that makes geometric or topological sense.
For example, the squares in~\cref{ex:concat-sym} must be constructed using the Kan operation.
Kan operation takes a description of some parts of an $n$-dimensional cube
(an \textit{incomplete} cube, or a \textit{partial} cube) and completes it.
To describe the input of Kan operations, we introduce partial elements.
\begin{terminology}
We follow the terminology in~\cite{CubicalAgda}.
In~\cite{CCHM}, partial elements are called \textit{systems}.
\end{terminology}
When we write \fbox{$x:\II,y:\II\vdash u:A$},
we are describing the following 2-dimensional cube, which is a square:
\carloCTikZ{\carloXy
\foreach \x in {0,1}
\foreach \y in {0,1}
  \node (\x\y) at (\x , \y) {\textbullet} ;
\fill [pattern color=gray,pattern=north west lines] (0,0) rectangle (1,1) ;
\node (center) at (0.5, 0.5) {$u:A$} ;}
For simplicity we assume \fbox{$\vdash \isType{A}$}, say, $A$ does not depend on $x$ or $y$.

Suppose we want to use the Kan operation to construct
a square \fbox{$x:\II,y:\II\vdash u:A$}
such that its top-left corner is a point $a:A$, and the line on its
right-hand side is a line $y:\II \vdash v:A$:
\carloCTikZ{\carloXy
\foreach \y in {0,1} \node (1\y) at (1 , \y) {\textbullet} ;
\node (00) at (0, 0) {$a$};
\node (01) at (0, 1) {\textbullet};
\draw (10) -- node [right] {$v$} (11); %
% \fill [pattern color=gray,pattern=north west lines] (0,0) rectangle (1,1) ;
% \node (center) at (0.5, 0.5) {$u:A$} ;
}

Translating that to type theory,
the goal is to construct the term $u$ such that
$u[\lcon/x, \rcon/y]\equiv a$ and $u[\rcon/x]\equiv v$.
The construction will be discussed in later sections,
and for now we focus on how to describe these partial boundaries
(also known as \textit{configurations} of a cube).
We introduce a straightforward syntax called \textit{partial elements}
for these cubes, e.g. the above partial element is written as:
\[\LRbbar{\begin{array}{rc}
  x\equiv\lcon \land y\equiv\rcon&\mapsto a\\
  x\equiv\rcon &\mapsto v
\end{array}}\]
To define this formally, we need to define the syntax of the left-hand-side of $\mapsto$.
They are called \textit{cofibrations} in \CTT.
\begin{terminology}
In~\cite{CCHM}, cofibrations are called \textit{face restrictions},
which is more (geometrically) intuitive but also longer.
\end{terminology}
The syntax of a cofibration is defined to be a disjunction normal form
(a disjunction list of conjunctions) of
face ``conditions'' like $x\equiv\lcon$ or $x\equiv\rcon$, as in~\cref{fig:cofib}.
\begin{figure}[h!]
\[\begin{array}{rll}
  \cond ::= & x\equiv\lcon \mid x\equiv\rcon & \text{condition} \\
  \conj ::= & \cond \mid \cond \land \conj & \text{conjunction} \\
  \disj ::= & \conj \mid \conj \lor \disj & \text{disjunction}
\end{array}\]
\caption{Syntax of cofibrations}
\label{fig:cofib}
\end{figure}

The meaning of cofibrations is simple. Suppose we are talking about a $3$-dimensional cube,
so we are in a context with $3$ intervals, say, $\Phi=x:\II,y:\II,z:\II$.
Then:
\begin{itemize}
\item As mentioned before, the term \fbox{$\Phi\vdash u:A$} corresponds to a cube:
\carloCTikZ{\carloXyz \refcube{Empty}}
\item A $\cond$ specifies a $2$-cube (a square) face in $\Phi$. For example, $x\equiv\lcon$
corresponds to the following square:
\carloCTikZ{\carloXyz \refcube{XEquivL}}
\item A $\conj$ specifies any $n$-cube (for $n\leq 2$) in $\Phi$. For example, $x=\lcon\land y=\rcon$ specifies a line,
and $x=\lcon\land y=\rcon\land z=\lcon$ specifies a point:
\item A $\disj$ talks about several $n$-cubes (for $n\leq 2$) in $\Phi$ at the same time.
\end{itemize}
Using cofibrations, we define the syntax of partial elements
by extending the syntax for terms in~\cref{fig:partial}
(recall~\cref{not:pre}).
\begin{figure}[h!]
\[\begin{array}{rl}
	\face::=&\conj\mapsto u \mid \conj\mapsto u,\face\\
	u,A::=&\lrbbar{\face} \mid \Partial{\disj}{A} \mid \cdots~\text{(other term formers)}
\end{array}\]
\caption{Syntax of partial elements}
\label{fig:partial}
\end{figure}

Note that we also need to define the type of partial elements,
and the type needs to contain the following two pieces of information:
\begin{itemize}
\item The faces being specified, $\disj$.
\item The type of the faces, $A$.
\end{itemize}
There are several advantages to use a disjunction normal form:
\begin{itemize}
\item We can put $\conj$ to the left-hand-side of $\mapsto$,
so every clause in a partial element is a single face.
\item It is easy to get the type of a partial element.
\end{itemize}

