\section{Introduction}
Throughout this tutorial, \fbox{boxes} will be used in the following two cases:
\begin{itemize}
\item to clarify the precedences of symbols when formulae become too large. \\
e.g. \fbox{$\Gvdash \fbox{$\lam x M$}~:~\fbox{$(y:A)\to B$}
\Leftarrow \fbox{$\lam x u$}$}.
\item to distinguish type theory terms from natural language text. \\
e.g. ``we combine a term \fbox{$a$} with a term \fbox{$b$} to get a term \fbox{$a~b$}''.
\end{itemize}
\subsection{Target Audience}
This tutorial assumes familiarity with the following:
\begin{itemize}
\item Dependent type theory concepts, such as formation rules,
introduction rules, eliminators, etc., and functional programming.
\item Programming and theorem proving in a proof assistant based on dependent type theories.
\item The ability to translate (simple) typing rules into a type-checking procedures
and combine them into an algorithm.
\item Basic understanding of De Morgan cubical type theory~\cite{CCHM,CHM}
(hereafter as \CTT{}), including the interval type $\II$, the path type,
and the idea of representing cubes using terms with interval variables in it.
\end{itemize}
This tutorial will not treat substitution formally.
Variable names are assumed to respect capture-avoiding substitution,
and can be implemented using any nameless representations.

Some quick warm-ups:
\begin{exercise}
Translate the following typing rules into an algorithmic description:
\begin{mathpar}
\inferrule{\Gamma,x:A\vdash b:B[x/y]}{\Gvdash \fbox{$\lam x b$} : (y:A)\to B} \and
\inferrule{\Gvdash u : (x:A)\to B \\ \Gvdash v:A}{\Gvdash u~v:B[v/x]}
\end{mathpar}
Which of them is an introduction rule, and which is an elimination rule?
\end{exercise}
\begin{notation}\label{not:pre}
In this tutorial, we will use $x, y, i, j, k$ for variables
(preferably $i, j, k$ for those of type $\II$ and $x, y$ otherwise)
and other Latin letters like $u,v,a,b,c,A,B,C$ for terms
(preferably uppercase for types and lowercase for terms).

We will write $u, A::=$ for syntax definition of terms.

Instead of the more traditional \fbox{$\lambda x.b$},
the notation for $\lambda$-abstraction is \fbox{$\lam x b$} 
following the style of the Arend language.

Substitution is denoted by $u[v/x]$.
One may think of this notation as ``fractional multiplication'' $u\times \frac v x$,
where the denominator $x$ is cancelled out from $u$ and \textit{replaced} with the numerator $v$.
Other authors may use $u[x\mapsto v]$, $u[x:=v]$, $[v/x]u$, etc.

Propositional equality and path equivalence are both denoted $u=v$,
while definitional equality (a.k.a. judgmental equality) is denoted $u\equiv v$.
\end{notation}
\begin{exercise}\label{ex:concat-sym}
Consider path concatenation and symmetry in \CTT{}:
\begin{align*}
\concat&:(p:a=b)\to(q:b=c)\to{a=c}\\
\sym&:(p:a=b)\to{b=a}
\end{align*}
Define both using \hcomp{} on the following squares,
preferably in a cubical programming language:
% https://q.uiver.app/?q=WzAsOCxbMCwwLCJhIl0sWzEsMCwiYyJdLFswLDEsImEiXSxbMSwxLCJiIl0sWzIsMSwiYSJdLFsyLDAsImIiXSxbMywxLCJhIl0sWzMsMCwiYSJdLFswLDEsIlxcY29uY2F0KHAsIHEpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzIsMCwiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiwzLCJwIiwyXSxbMywxLCJxIiwyXSxbNCw1LCJwIl0sWzQsNiwiIiwyLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiw3LCIiLDIseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs1LDcsIlxcc3ltKHApIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\[\begin{tikzcd}
	a & c & b & a \\
	a & b & a & a
	\arrow["{\concat(p, q)}", dashed, from=1-1, to=1-2]
	\arrow[Rightarrow, no head, from=2-1, to=1-1]
	\arrow["p"', from=2-1, to=2-2]
	\arrow["q"', from=2-2, to=1-2]
	\arrow["p", from=2-3, to=1-3]
	\arrow[Rightarrow, no head, from=2-3, to=2-4]
	\arrow[Rightarrow, no head, from=2-4, to=1-4]
	\arrow["{\sym(p)}", dashed, from=1-3, to=1-4]
\end{tikzcd}\]
\end{exercise}
\subsection{Motivation}
This tutorial is intended to help readers get more familiar with how
\CTT{} works, what difficulties it is having in implementations,
what it can already do, and what it cannot do yet.

\CTT{} is a type theory evolved from a model using Kan cubical sets~\cite{CubicalSets},
which uses sophisticated mathematics, while computer scientists
usually do not have relevant courses taught in their undergraduate program.
But it is also the computer scientists who are suppose to implement \CTT{} as
programming languages. This tutorial tries to help those who did not study homotopy
theory, but wish to learn the internals of \CTT.

\CTT{} extends Martin-L\"{o}f type theory with a huge amount of new constructions,
especially the typing rules are written in a very compact way (like in~\cite{HCompPDF}).
This tutorial aims to discuss them from an algorithmic perspective,
and hopefully to inspire more people to implement cubical type theory,
to fuse these ideas into other work, or just to worship these brilliant ideas.

This tutorial is a by-product of an experiment in implementing \CTT, called \GuestName,
a project created to encourage a particular person to learn \CTT.
The story ends up in the worst way: the person did not learn \CTT, and instead created
a new project to encourage the author of \GuestName{} to learn extensional type theory.

\section{Type checking cubes}\label{sec:tyck-cube}
This section motivates and explains typing judgments with cofibrations in the context.

\subsection{Interval and contexts}\label{sub:interval}
In \CTT, we have the interval type:
\[\vdash \isType\II\quad \vdash \lcon:\II \quad \vdash \rcon:\II\]
The interval type and its products are used to represent dimensions
(ignoring the De Morgan structures for now).
\begin{example}\label{ex:interval-in-ctx}
Suppose \fbox{$i:\II\vdash\isType{A}$} and \fbox{$i:\II\vdash u:A$}.
From a semantical or a topological perspective, we can say:
\begin{itemize}
\item $A$ is a (type) line between $A[\lcon/i]$ and $A[\rcon/i]$.
\item $u$ is a (term) line between $u[\lcon/i]$ and $u[\rcon/i]$.
\item The type of a line is a line, so the type of $u$ is $A$.
\end{itemize}
Then, because \emph{typing relations are preserved by substitution},
we have $u[\rcon/i]:A[\rcon/i]$ and $u[\lcon/i]:A[\lcon/i]$.
% https://q.uiver.app/?q=WzAsNixbMCwwLCJ1W1xcbGNvbi9pXSJdLFswLDEsInVbXFxyY29uL2ldIl0sWzIsMCwiQVtcXGxjb24vaV0iXSxbMiwxLCJBW1xcbGNvbi9pXSJdLFsxLDBdLFsxLDFdLFswLDEsInUiXSxbMiwzLCJBIl0sWzQsNSwiOiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}
	{u[\lcon/i]} & {} & {A[\lcon/i]} \\
	{u[\rcon/i]} & {} & {A[\lcon/i]}
	\arrow["u", from=1-1, to=2-1]
	\arrow["A", from=1-3, to=2-3]
	\arrow["{:}"{description}, draw=none, from=1-2, to=2-2]
\end{tikzcd}\]
\end{example}
From~\cref{ex:interval-in-ctx} we motivate the following notational
convention for contexts in \CTT, as in~\cref{not:ctx}.
\begin{notation}\label{not:ctx}
Typing judgments are written as \fbox{$\PGvdash \isType{A}$} and \fbox{$\PGvdash u:A$},
where \fbox{$\Phi;\Gamma$} is the usual \textit{context} in type theories,
with variables classified into two groups: if a variable has type $\II$,
it goes to $\Phi$, otherwise it goes to $\Gamma$.
This convention is borrowed from~\cite{ABCFHL}.
\end{notation}
Note that~\cref{not:ctx} does not imply that contexts has to be classified
in the implementations. The \GuestName{} type checker mix intervals
and other bindings in a unified context, just like usual dependent type checkers.

\subsection{Partial elements}\label{sub:partial}
In \CTT, we may not be able to describe every cube using a term,
like the squares in~\cref{ex:concat-sym}.
This motivates the idea of partial elements.
\begin{terminology}
We follow the terminology in~\cite{CubicalAgda}.
In~\cite{CCHM}, partial elements are called \textit{systems}.
\end{terminology}
Suppose we want to describe a square \fbox{$i:\II,j:\II\vdash u:A$},
where $i$ goes from left to right and $j$ goes from bottom to top.
For simplicity we assume \fbox{$\vdash \isType{A}$}, say, $A$ does not depend on $i$ or $j$.
% https://q.uiver.app/?q=WzAsMyxbMCwxXSxbMSwxXSxbMCwwXSxbMCwxLCJpIl0sWzAsMiwiaiIsMl1d
\[\begin{tikzcd}
	{} \\
	{} & {}
	\arrow["i", from=2-1, to=2-2]
	\arrow["j"', from=2-1, to=1-1]
\end{tikzcd}\]
The goal is to make $u[\lcon/i, \rcon/j]\equiv a$ and $u[\rcon/i]\equiv v$.
From the goal we may deduce $\vdash a:A$ and $j:\II\vdash v:A$.
% https://q.uiver.app/?q=WzAsMyxbMCwwLCJhIl0sWzEsMCwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDFdLFsyLDEsInYiLDJdXQ==
\[\begin{tikzcd}
	a & \bullet \\
	& \bullet
	\arrow[from=1-1, to=1-2]
	\arrow["v"', from=2-2, to=1-2]
\end{tikzcd}\]
The above ``describing a cube by describing parts of its boundaries''
process is a just-need of \CTT, and such descriptions are called \textit{partial elements}
(also informally called a \textit{configuration} of a cube).
In \CTT, we need a syntax for partial elements.
Intuitively we may write something like this:
\[\LRbbar{\begin{array}{rc}
  i\equiv\lcon \land j\equiv\rcon&\mapsto a\\
  i\equiv\rcon &\mapsto v
\end{array}}\]
To define this formally, we need to define the syntax of the left-hand-side of $\mapsto$.
They are called \textit{cofibrations} in \CTT.
\begin{terminology}
In~\cite{CCHM}, cofibrations are called \textit{face restrictions},
which is more (geometrically) intuitive but also longer.
\end{terminology}
The syntax of a cofibration is defined to be a disjunction normal form
(a disjunction list of conjunctions) of
face ``conditions'' like $i\equiv\lcon$ or $i\equiv\rcon$, as in~\cref{fig:cofib}.
\begin{figure}[h!]
\[\begin{array}{rll}
  \cond ::= & i\equiv\lcon \mid i\equiv\rcon & \text{condition} \\
  \conj ::= & \cond \mid \cond \land \conj & \text{conjunction} \\
  \disj ::= & \conj \mid \conj \lor \disj & \text{disjunction}
\end{array}\]
\caption{Syntax of cofibrations}
\label{fig:cofib}
\end{figure}

The meaning of cofibrations is simple. Suppose we are talking about a $3$-dimensional cube,
so we are in a context with $3$ intervals, say, $\Phi=i:\II,j:\II,k:\II$.
Then:
\begin{itemize}
\item $\cond$ specifies a $2$-cube (a square) in $\Phi$.
\item $\conj$ specifies any $n$-cube (for $n\leq 2$) in $\Phi$. For example, $i=\lcon\land j=\rcon$ specifies a line,
and $i=\lcon\land j=\rcon\land k=\lcon$ specifies a point (note that this point is on the line).
\item $\disj$ talks about several $n$-cubes (for $n\leq 2$) in $\Phi$ at the same time.
\end{itemize}
Using cofibrations, we define the syntax of partial elements
by extending the syntax for terms in~\cref{fig:partial}
(recall~\cref{not:pre}).
\begin{figure}[h!]
\[\begin{array}{rl}
	\face::=&\conj\mapsto u \mid \conj\mapsto u,\face\\
	u,A::=&\lrbbar{\face} \mid \Partial{\disj}{A} \mid \cdots~\text{(other term formers)}
\end{array}\]
\caption{Syntax of partial elements}
\label{fig:partial}
\end{figure}

Note that we also need to define the type of partial elements,
and the type needs to contain the following two pieces of information:
\begin{itemize}
\item The faces being specified, $\disj$.
\item The type of the faces, $A$.
\end{itemize}
There are several advantages to use a disjunction normal form:
\begin{itemize}
\item We can put $\conj$ to the left-hand-side of $\mapsto$,
so every clause in a partial element is a single face.
\item It is easy to get the type of a partial element.
\end{itemize}

\[
	\carloTikZ{
		\foreach \x in {0,1}
			\foreach \y in {0,1}
				\node (\x\y) at (\x , \y) {\textbullet} ;
		\draw (00) to node [above] {$p$} (10) ;
		\draw (10) to node [right] {$q$} (11) ;
		\draw (00) to node (r) [left] {$r$} (01) ;
		\draw [dashed] (01) to (11) ;
		\fill [pattern color=gray,pattern=north west lines] (0,0) rectangle (1,1) ;
	}
	:=
	\carloTikZ{\carloCubeBullets
		% left
		\draw [draw=white,line width=3pt,fill=black!50,fill opacity=0.5]
			(0,0,0) -- (0,1,0) -- (0,1,1) -- (0,0,1) -- cycle ;
		\node (r) at (0,0.5,0.5) {$r'$} ;
		\draw (001) -- (011) ;
		% back
		\draw [draw=white,line width=3pt,fill=black!50,fill opacity=0.5]
			(0,0,0) -- (1,0,0) -- (1,1,0) -- (0,1,0) -- cycle ;
		\draw [equals arrow] (000) -- (010) ;
		\draw (010) -- (110) ;
		% top
		\draw [draw=white,line width=3pt,fill=black!50,fill opacity=0.5]
			(0,0,0) -- (1,0,0) -- (1,0,1) -- (0,0,1) -- cycle ;
		\node at (0.5,0,0.5) {$p$} ;
		\foreach \i in {0,1} \draw (00\i) -- (10\i) ;
		\fill [pattern color=gray,pattern=north west lines]
			(0,1,0) -- (1,1,0) -- (1,1,1) -- (0,1,1) -- cycle ;
		% right
		\draw [draw=white,line width=3pt,fill=black!50,fill opacity=0.5]
			(1,0,0) -- (1,1,0) -- (1,1,1) -- (1,0,1) -- cycle ;
		\node at (1,0.5,0.5) {$q'$} ;
		\draw [equals arrow] (100) -- (110) ;
		\draw (101) -- (111) ;
		\foreach \i in {0,1} \draw [shorten <>= -3pt, equals arrow] (\i 00) to (\i 01) ;
		\foreach \i in {0,1} \draw [shorten <>= -3pt] (\i 10) to (\i 11) ;
		\draw [dashed] (011) -- (111) ;
	}
\]
